import { loadMarkdownFiles, MarkdownChunk } from './markdownLoader';
import { embedAndStore, searchSimilar, searchByType, getCollectionStats, checkConnection } from './vectorStore';

/**
 * G≈Ç√≥wna funkcja integrujƒÖca markdown loader z vector store
 * ≈Åaduje pliki markdown i zapisuje je jako embeddings w ChromaDB
 * @param contentDir - ≈öcie≈ºka do katalogu z plikami markdown
 * @param chunkSize - Rozmiar chunk√≥w (domy≈õlnie 500)
 * @param overlap - Nak≈Çadanie miƒôdzy chunkami (domy≈õlnie 100)
 * @returns Promise<Object> - Statystyki operacji
 */
export async function loadAndStoreContent(
  contentDir: string = './content',
  chunkSize: number = 500,
  overlap: number = 100
): Promise<{
  success: boolean;
  chunksLoaded: number;
  chunksStored: number;
  stats: any;
  error?: string;
}> {
  try {
    console.log('üöÄ Rozpoczynam ≈Çadowanie i zapisywanie tre≈õci...');
    
    // Sprawd≈∫ po≈ÇƒÖczenie z ChromaDB
    const isConnected = await checkConnection();
    if (!isConnected) {
      throw new Error('Brak po≈ÇƒÖczenia z ChromaDB. Upewnij siƒô, ≈ºe serwer dzia≈Ça na localhost:8000');
    }

    // Za≈Çaduj pliki markdown
    console.log('üìÅ ≈Åadowanie plik√≥w markdown...');
    const chunks = await loadMarkdownFiles(contentDir, chunkSize, overlap);
    
    if (chunks.length === 0) {
      return {
        success: false,
        chunksLoaded: 0,
        chunksStored: 0,
        stats: null,
        error: 'Nie znaleziono plik√≥w markdown do za≈Çadowania'
      };
    }

    console.log(`‚úÖ Za≈Çadowano ${chunks.length} chunk√≥w`);

    // Zapisz jako embeddings
    console.log('üíæ Zapisywanie embeddings...');
    await embedAndStore(chunks);

    // Pobierz statystyki
    const stats = await getCollectionStats();

    console.log('üéâ Pomy≈õlnie zako≈Ñczono ≈Çadowanie i zapisywanie tre≈õci!');
    
    return {
      success: true,
      chunksLoaded: chunks.length,
      chunksStored: chunks.length,
      stats
    };

  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd podczas ≈Çadowania i zapisywania tre≈õci:', error);
    return {
      success: false,
      chunksLoaded: 0,
      chunksStored: 0,
      stats: null,
      error: error instanceof Error ? error.message : 'Nieznany b≈ÇƒÖd'
    };
  }
}

/**
 * Wyszukuje tre≈õci podobne do zapytania
 * @param query - Zapytanie do wyszukania
 * @param limit - Maksymalna liczba wynik√≥w
 * @returns Promise<Array> - Array podobnych tre≈õci
 */
export async function searchContent(query: string, limit: number = 3): Promise<any[]> {
  try {
    console.log(`üîç Wyszukiwanie: "${query}"`);
    const results = await searchSimilar(query, limit);
    return results;
  } catch (error) {
    console.error('B≈ÇƒÖd wyszukiwania:', error);
    return [];
  }
}

/**
 * Wyszukuje tre≈õci wed≈Çug typu
 * @param type - Typ tre≈õci (blok, atak, przepisy, etc.)
 * @param limit - Maksymalna liczba wynik√≥w
 * @returns Promise<Array> - Array tre≈õci danego typu
 */
export async function getContentByType(type: string, limit: number = 5): Promise<any[]> {
  try {
    console.log(`üìÇ Wyszukiwanie tre≈õci typu: ${type}`);
    const results = await searchByType(type, limit);
    return results;
  } catch (error) {
    console.error('B≈ÇƒÖd wyszukiwania wed≈Çug typu:', error);
    return [];
  }
}

/**
 * Pobiera statystyki bazy danych
 * @returns Promise<Object> - Statystyki bazy danych
 */
export async function getDatabaseStats(): Promise<any> {
  try {
    const stats = await getCollectionStats();
    return stats;
  } catch (error) {
    console.error('B≈ÇƒÖd pobierania statystyk:', error);
    return null;
  }
}

/**
 * Sprawdza status systemu
 * @returns Promise<Object> - Status systemu
 */
export async function getSystemStatus(): Promise<{
  chromaDB: boolean;
  openai: boolean;
  contentDir: boolean;
  stats?: any;
}> {
  try {
    const chromaDB = await checkConnection();
    const openai = !!process.env.OPENAI_API_KEY;
    const contentDir = true; // Mo≈ºna dodaƒá sprawdzenie istnienia katalogu
    
    let stats = null;
    if (chromaDB) {
      stats = await getDatabaseStats();
    }

    return {
      chromaDB,
      openai,
      contentDir,
      stats
    };
  } catch (error) {
    console.error('B≈ÇƒÖd sprawdzania statusu systemu:', error);
    return {
      chromaDB: false,
      openai: false,
      contentDir: false
    };
  }
}

/**
 * Przyk≈Çad u≈ºycia - ≈Çaduje tre≈õci i wykonuje wyszukiwanie
 */
export async function exampleUsage() {
  console.log('üß™ Przyk≈Çad u≈ºycia systemu vector store...\n');

  try {
    // 1. Sprawd≈∫ status systemu
    console.log('1. Sprawdzanie statusu systemu...');
    const status = await getSystemStatus();
    console.log('Status:', status);

    // 2. Za≈Çaduj i zapisz tre≈õci
    console.log('\n2. ≈Åadowanie i zapisywanie tre≈õci...');
    const loadResult = await loadAndStoreContent('./content', 500, 100);
    console.log('Wynik ≈Çadowania:', loadResult);

    // 3. Wyszukaj podobne tre≈õci
    console.log('\n3. Wyszukiwanie podobnych tre≈õci...');
    const searchResults = await searchContent('technika ataku', 3);
    console.log('Wyniki wyszukiwania:', searchResults);

    // 4. Wyszukaj wed≈Çug typu
    console.log('\n4. Wyszukiwanie wed≈Çug typu...');
    const typeResults = await getContentByType('atak', 2);
    console.log('Tre≈õci typu "atak":', typeResults);

    // 5. Pobierz statystyki
    console.log('\n5. Statystyki bazy danych...');
    const stats = await getDatabaseStats();
    console.log('Statystyki:', stats);

  } catch (error) {
    console.error('B≈ÇƒÖd w przyk≈Çadzie u≈ºycia:', error);
  }
}
